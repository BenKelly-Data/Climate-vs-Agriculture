# -*- coding: utf-8 -*-
"""INF1340 Final Assignment (G15): Crop Yield & Climate Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at:
    https://colab.research.google.com/drive/1sEcezR13fLWKICQGDxlkSFKFCUAswJd1?usp=sharing

# Canadian Crop Yield & Climate Analysis

**INF1340**

**Sheldon Chen, Lo Humeniuk, Bejamin Kelly, Will Power-Jenkins**

**December 13, 2021**

*Our project involves looking at Canadian agricultural data and comparing annual 
#crop-yield information with yearly climate data (specifically temperature and 
#precipitation). We will be inputting data found from Statistics Canada and 
#Climate Change Canada, and creating a program to both visualize this data and 
#explore correlations between yields and climate. Initial input will take the 
#form of a .csv file but if there is time and desire for more complexity we will 
#be exploring data-scraping techniques in order to keep information up to date 
#and automatic. Ideally, the user will have the option to filter data by year, 
#by crop, and by province, and produce some basic linear regression results 
#based on the data-views selected. Other variables will be included if there 
#is time, as well as the ability to compute some basic forecasting trends based 
#on historical data.*

## Reading the Dataset
"""
!pip3 install stats-can #Install the Statitsics Canada API
#conda install -c conda-forge stats_can
import pandas as pd
import numpy as np

from stats_can import StatsCan #Import StatsCan library 
sc = StatsCan()
crop_yield = sc.table_to_df("32-10-0359-01") #Convert crop yield data table into pandas dataframe

crop_yield.columns = [c.replace(' ', '_') for c in crop_yield.columns] #Improve header readability

#Drop unnecessary columns from crop yield table
crop_yield = crop_yield.drop(columns=["DGUID"]) 
crop_yield = crop_yield.drop(crop_yield.loc[:,"UOM_ID":"COORDINATE"].columns, axis = 1)
crop_yield = crop_yield.drop(crop_yield.loc[:,"STATUS":"DECIMALS"].columns, axis = 1)
crop_yield = crop_yield.dropna() #Not sure on this one?

#Reset index based on new number of rows
crop_yield.reset_index(inplace=True)
crop_yield = crop_yield.drop("index", 1)

def redo_columns(df): #Find averages for provinces that have more than one weather station; amalgamate these averages into new columns named for provinces and discard remaining columns
  df['Alberta'] = df[['CALGARY', 'EDMONTON']].mean(axis=1)
  df['Quebec'] = df[['MONTREAL', 'QUEBEC']].mean(axis=1) #Means of multiple weather stations
  df['Ontario'] = df[['OTTAWA', 'TORONTO']].mean(axis=1)
  new_columns = {'MONCTON': 'New Brunswick',
        'SASKATOON': 'Saskatchewan',
        'STJOHNS': 'Newfoundland and Labrador',
        'VANCOUVER': 'British Columbia',
        'WINNIPEG': 'Manitoba',
        'HALIFAX': 'Nova Scotia',
        'CHARLOTTETOWN': 'Prince Edward Island'} #Dict to replace weather station names with provinces

  df.rename(columns=new_columns,
          inplace=True)

  df.drop(['CALGARY','EDMONTON','MONTREAL','OTTAWA','QUEBEC','TORONTO','WHITEHORSE'], axis = 1,inplace=True) #Remove columns that provided means 
  return df

##CODE FOR MANIPULATING PRECIPITATION DATA from PEI
# Not needed for code to run, just showing some work
# Similar code was created for temperature data

#precip = pd.read_csv('/content/drive/MyDrive/1340 Project/Data/precipitation data/Canadian_precipitation_2.csv')
#print(precip)

#Rename columns
#precip.columns = [p.replace('TOTAL_PRECIPITATION_', '') for p in precip.columns]

#precip= redo_columns(precip)
#precip.dtypes

#Find annual sums of precipitation from dataset
#Yearly_precip = precip_data.groupby(["LOCAL_DATE"]).sum()

#print(Yearly_precip)

#Import Charlottetown data up to 2012 because it was missing from other dataset -- note monthly data only exists in this new set up to 2012
#pei_precip_data_2012 = pd.read_csv('/content/drive/MyDrive/1340 Project/Data/en_climate_monthly_PE_8300300_1943-2012_P1M.csv')

#Find annual sums of precipitation from Charlottetown data up to 2012
#pei_Yearly_precip = pei_precip_data_2012.groupby(["Year"]).sum()

#Import amangamated data from Charlottetown from 2013 to 2019
#pei_precip_data_2013 = pd.read_csv('/content/drive/MyDrive/1340 Project/Data/pei_2013.csv')
#Change indexing so that the columns will match
#pei_precip_data_2013.set_index('YEAR', inplace = True)

#Combine all of the Charlottetown data
#pei_full_precip = (pei_Yearly_precip.append(pei_precip_data_2013)['Total Precip (mm)'])
#print(pei_full_precip)

#Combine Charlottetown data with earlier precipitation dataset that includes all other provinces
#fullset_precip = Yearly_precip.join(other=pei_full_precip)

#Rename column 
#fullset_precip.rename(columns = {'Total Precip (mm)':'Prince Edward Island'})

#export_csv = fullset_precip.to_csv (r'/content/drive/MyDrive/1340 Project/Data/precipitation_data_updated.csv', index = None, header=True)


#Provincial precipitation

#Read in broad temperature data (all and PEI)

temp = pd.read_csv('https://raw.githubusercontent.com/BenKelly-Data/Canadian-Agricutural-Yields-vs-Climate/main/temperature_data.csv')
pei_temp_2012 = pd.read_csv('https://raw.githubusercontent.com/BenKelly-Data/Canadian-Agricutural-Yields-vs-Climate/main/en_climate_monthly_PE_8300300_1943-2012_P1M.csv')
pei_Yearly_temp = pei_temp_2012.groupby(["Year"]).mean() #Mean data by year
pei_temp_data_2013 = pd.read_csv('https://raw.githubusercontent.com/BenKelly-Data/Canadian-Agricutural-Yields-vs-Climate/main/pei_2013.csv')
pei_temp_data_2013.set_index('YEAR', inplace = True)

#Select only temp data from PEI daata
pei_temp_data_2013 = pei_temp_data_2013[['Mean Temp (°C)']]
pei_Yearly_temp = pei_Yearly_temp[['Mean Temp (°C)']]
pei_temp = pei_Yearly_temp.append(pei_temp_data_2013) #Append 2013-2019 data to 90's-2012 data
#Match indexes between 
pei_temp['YEAR'] = pei_temp.index
temp.set_index('YEAR')

#Join PEI data to the rest of the provinces
temp = temp.join(pei_temp.set_index('YEAR'),on = 'YEAR',how = 'left')

#Match formating between columns and with precipitation data
temp.rename(columns = {'Mean Temp (°C)':'MEAN_TEMPERATURE_CHARLOTTETOWN'}, inplace = True)
temp.columns = [t.replace('MEAN_TEMPERATURE_', '') for t in temp.columns]

temp = redo_columns(temp)

#GitHub Precip Data
precip = pd.read_csv('https://raw.githubusercontent.com/BenKelly-Data/Canadian-Agricutural-Yields-vs-Climate/main/precipitation_data_updated.csv')
precip.rename(columns = {'Total Precip (mm)':'TOTAL_PRECIPITATION_CHARLOTTETOWN'}, inplace = True)
precip.columns = [p.replace('TOTAL_PRECIPITATION_', '') for p in precip.columns]

precip= redo_columns(precip)
precip['YEAR'] = temp['YEAR'] #Re-add year data

precip.drop(precip.tail(1).index,inplace = True) #Remove extra error row
precip['YEAR'] = precip['YEAR'].astype(int)

"""## Data Cleaning"""

#FOCUSSING ON PROVINCIAL DATA
provs = ['Alberta', 'British Columbia', 'Manitoba', 'New Brunswick', 
         'Newfoundland and Labrador', 'Nova Scotia', 'Ontario', 
         'Quebec', 'Saskatchewan','Prince Edward Island']

prov_ag = crop_yield[crop_yield['GEO'].isin(provs)] #Subset crop data to just provincial data (not national or regional)

prov_ag[["REF_DATE"]] = prov_ag[["REF_DATE"]].astype(str) #Change year to be a string

prov_ag=prov_ag.rename(columns = {'REF_DATE':'YEAR'})

prov_ag = prov_ag.replace({'-01-01': ''}, regex=True)
prov_ag[["YEAR"]] = prov_ag[["YEAR"]].astype(int)
prov_ag = prov_ag[prov_ag.YEAR >= 1940]
prov_ag = prov_ag[prov_ag.YEAR <= 2019]
prov_ag = prov_ag.reset_index()

#Might be able to make one function with temp/precip as an argument, but seems to get complicated within the apply
def inTemp(row):
  t = prov_ag.iloc[[row.name]] #Get row index of current row
  y = t['YEAR'] #Find the year associated with the row
  y = int(y) #Ensure it's an integer

  p = t['GEO'].astype("string").to_string() #Get province as string (redundancy needed)
  head, sep, p = p.partition('  ') #Clean extra space created by making the string
  p = p.lstrip() #Keep removing extra spaces
  test = temp.loc[temp['YEAR'] == y] #Get the temperatures for the given year
  v = test[p] #Select the temp for the given province within selected year
  return float(v) #Return temp

#Similar commenting as above, just adapted to precipitation data
def inPrecip(row):
  t = prov_ag.iloc[[row.name]]
  y = t['YEAR']
  y = int(y)

  p = t['GEO'].astype("string").to_string()
  head, sep, p = p.partition('  ')
  p = p.lstrip()
  test = precip.loc[precip['YEAR'] == y]
  v = test[p]
  return float(v)

print('')
print('Data formatting takes 6-10 minutes, thanks for waiting!')
print('')

#TAKES 3 MIN
#Add temperature column to crop yield data
prov_ag["TEMP"] = ''
prov_ag["TEMP"] = prov_ag.apply(inTemp, axis=1)

print('Temperature data is in, now for precipitation!')
print('')

#Add precipitation column to crop yield data
prov_ag["PRECIP"] = ''
prov_ag["PRECIP"] = prov_ag.apply(inPrecip, axis=1)

print('Data ready! Look for a GUI!')
print('')
"""

```
# This is formatted as code
```

## GUI Creation & MatPlotLib Integration"""

from tkinter import *
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import tkinter.messagebox

#crop_yield = pd.read_csv("dat.csv") # theoretically won't need this part once StatsCan gets back up and running
crop_yield = prov_ag

# Generates the values for the drop down menus and sorts the lists for easier readability
province_list = sorted(crop_yield["GEO"].unique())
crop_list = sorted(crop_yield["Type_of_crop"].unique())
prov_ag = crop_yield

# Error message generation for bad values (mostly in Newfoundland set)
def expected_vector():
  tkinter.messagebox.showerror("TypeError", "Expected non-empty vector for x: \nData has no value for province and crop selected")


class Graph:
  def __init__(self, Prov, CropTp, TempORPrecip):
    self.Prov = Prov
    self.CropTp = CropTp
    self.TempORPrecip = TempORPrecip
    self.__setData__()
    self.__display__()

  def __setData__(self):
    self.X = (prov_ag[(prov_ag.GEO == self.Prov) & 
                   (prov_ag.Type_of_crop == self.CropTp)
                 & (prov_ag.Harvest_disposition == 
                    'Average yield (kilograms per hectare)')
                ].dropna()["YEAR"]).values 
    self.production = (prov_ag[(prov_ag.GEO == self.Prov) & 
                   (prov_ag.Type_of_crop == self.CropTp)
                 & (prov_ag.Harvest_disposition == 
                    'Average yield (kilograms per hectare)')
                ].dropna()["VALUE"]).values           
    if self.TempORPrecip == 'TEMP':
      self.key = 'TEMP'
    else:
      self.key = 'PRECIP'      
    self.independentVAR = (prov_ag[(prov_ag.GEO == self.Prov) & 
                   (prov_ag.Type_of_crop == self.CropTp)
                 & (prov_ag.Harvest_disposition == 
                    'Average yield (kilograms per hectare)')
                ].dropna()[self.key]).values

  def __display__(self):
    
    self.max_temp =  max((prov_ag["TEMP"].dropna()).values)
    self.min_temp =  min((prov_ag["TEMP"].dropna()).values)
    self.max_precip =  max((prov_ag["PRECIP"].dropna()).values)
    self.max_yield = max((prov_ag[(prov_ag.Type_of_crop == self.CropTp) & 
                        (prov_ag.Harvest_disposition == 
                         'Average yield (kilograms per hectare)')]["VALUE"]
                .dropna()).values)

    try:
      fig, ax1 = plt.subplots()

      ax2 = ax1.twinx()
      ax1.plot(self.X, self.production, 'o', color = 'lightcoral', 
              label = 'Average Yield')
      ax1.set_ylim(0,1000 + self.max_yield) 
      ax1.set_xlabel('Year')
      ax1.set_ylabel('kilograms per hectare')  
      
      if self.key == 'TEMP':
        ax2.plot(self.X, self.independentVAR, 'o', color = 'peachpuff', 
              label = 'Temperature')
        ax2.set_ylim(self.min_temp-2, self.max_temp+2)
        ax2.set_ylabel('Celsius')
      else:
        ax2.plot(self.X, self.independentVAR, 'o', color = 'lightblue', 
              label = 'Precipitation') 
        ax2.set_ylim(0, self.max_precip+2)      
        ax2.set_ylabel('100mm') 

      fig.legend(loc='upper left', bbox_to_anchor=(0.12, 0.9))

      m, b = np.polyfit(self.X, self.production, 1)
      m1, b1 = np.polyfit(self.X, self.independentVAR, 1)

      ax1.plot(self.X, m*self.X+b, color='lightcoral')
      if self.key == "TEMP":
        ax2.plot(self.X, m1*self.X+b1, color='peachpuff')
      else:
        ax2.plot(self.X, m1*self.X+b1, color='lightblue')

      if self.key == "TEMP":
          climate1 = "Temperature"
      else:
          climate1 = "Precipitation"

      plt.title("Relationship between {} and Crop Yield ({}) \nin {} from 1940 to Present".format(climate1, self.CropTp, self.Prov))

      plt.show()
    except TypeError:
      expected_vector()

# Class for the main GUI - presents the user with options to select province, crop type, and climate type to 
# generate a plot, as well as to exit the application 
class MainGUI:
    def __display__(self):
        Graph()
    
    def __init__(self, master):
        self.master = master
        Frame1 = Frame(self.master)
        Frame1.grid()

        # Brief set of instructions
        self.prompt = Message(master, text="Choose a province, a type of crop, and one of temperature or precipitation to see the relationship.", fg = "white", bg = def_back, width = 400, justify="center")
        self.prompt.configure(font=("arial", 9, "bold"), borderwidth = 1, relief = GROOVE)
        self.prompt.grid(row = 1, column = 1, pady = 15, padx = 5, columnspan=2)

        # Creates dropdown menu for provinces
        self.Province = StringVar()
        self.Province.set("Alberta")
        self.ProvinceSelect = OptionMenu(master, self.Province, *province_list, command = lambda _: self.getProvince())
        self.ProvinceSelect.grid(row = 2, column = 2, pady = 5, padx = 5)
        self.ProvinceSelect["highlightthickness"]=0
        self.ProvinceSelect.config(bg = "Slategray3")
        self.ProvLabel = Label(master, text = "Select a province:", fg = "white", bg = def_back,)
        self.ProvLabel.grid(row = 2, column = 1, padx = 5)

        # Creates drop down menu for crop types
        self.CropType = StringVar()
        self.CropType.set("Barley")
        self.CropSelect = OptionMenu(master, self.CropType, *crop_list, command = lambda _: self.getCrop())
        self.CropSelect.grid(row = 3, column = 2, pady = 5, padx = 5)
        self.CropSelect["highlightthickness"]=0
        self.CropSelect.config(bg = "Slategray3")
        self.CropLabel = Label(master, text = "Select a crop:", fg = "white", bg = def_back,)
        self.CropLabel.grid(row = 3, column = 1, padx = 5)

        # Creates drop down menu for climate type
        self.ClimateType = StringVar()
        self.ClimateType.set("TEMP")
        self.ClimateSelect = OptionMenu(master, self.ClimateType, "TEMP", "PRECIP", command = lambda _: self.getClimate())
        self.ClimateSelect.grid(row = 4, column = 2, pady = 5, padx = 5)
        self.ClimateSelect.config(bg = "Slategray3")
        self.ClimateSelect["highlightthickness"]=0
        self.ClimateLabel = Label(master, text = "Temperature or Precipitation:", fg = "white", bg = def_back,)
        self.ClimateLabel.grid(row = 4, column = 1, padx = 5)

        self.interact()

    def interact(self):
        
        #First butto calls the Graph class functions and plots the data based on user input from the drop down menus
        self.button_1 = Button(self.master , text="Plot", command= lambda : Graph(self.Province.get(), self.CropType.get(), self.ClimateType.get()), bg="papayawhip")
        self.button_1.grid(row = 5, column = 2, pady = 10, padx = 5)  ##plot

        # Button that calls the _quit function to exit the program
        self.button_2 = Button(self.master , text="Quit", command=self._quit, bg="salmon")
        self.button_2.grid(row = 6, column = 2, pady = 10, padx = 5)

    # Destroys the mainloop instance    
    def _quit(self):
        window.quit()
        window.destroy()

    # The 3 functions below store the option selected via the drop down menus as a value to be worked with
    # If no option is selected, the default values of "Alberta", "Barley", and "TEMP" will be used
    def getProvince(self):
        global Province
        ProvinceGet = self.Province.get()

    def getCrop(self):
        global CropGet
        CropGet = self.CropType.get()

    def getClimate(self):
        global ClimateGet
        ClimateGet = self.ClimateType.get()

# calls the GUI and creates an instance
if __name__ == '__main__':

    window = Tk()
    window.title("Canadian Crop Yield Analysis")
    window.configure(bg = "SkyBlue4")

    def_back = "SkyBlue4"

    app1_inst = MainGUI(window)

    window.mainloop()

"""## Linear Regression Analysis"""

!pip install sklearn
!pip install numpy
!pip install matplotlib
!pip install statsmodels

import statsmodels.api as sm
import statsmodels.formula.api as smf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

#Step 1: Testing the existence of a linear relationship between climate change
#and agricultural crop yield in Canada

#Declare Global Constants to be used as queries
DEFAULT_YEAR = 2018
DEFAULT_CROP = 'Barley'
SIGNIFICANCE_LEVEL = 0.05

#class to summarize if there is a linear correlation 
#between each pair of (temp, precip) (yield) variables

class LinearValidate:
  '''
  Return a dataframe summarizing the existence of a linear correlation 
  between each pair of (temp, precip) (crop_type) variables in each province.
  Each row of this returned data frame has three columns 'Province_name', 
  'Crop_name', 'Existence_of_linear_relation' 

  Example output:
  Province_name   Crop_name   Existence_of_linear_relation
  Alberta         Barley      No
  Alberta         ...         ...
  ...             ...         ...
  ...             ...         ...
  Saskachewan     Wheat       No
  '''

  def __init__(self):
    self.Harvest_disposition = 'Average yield (kilograms per hectare)'
    self.ProvLst = prov_ag[(prov_ag.YEAR	== 2018) & 
                           (prov_ag.Type_of_crop.str.contains(DEFAULT_CROP)) &
               (prov_ag.Harvest_disposition == self.Harvest_disposition)].GEO.values    
    self.ProvRecord = []
    self.CropRecord = []
    self.FTestRecord = []
    self.validate(prov_ag)
  
  def ProvCropType(self, Df_ag, Prov):
    return prov_ag[(prov_ag.GEO == Prov) & (prov_ag.YEAR	== DEFAULT_YEAR) & 
                   (prov_ag.Harvest_disposition == self.Harvest_disposition)].Type_of_crop.values

  def validate(self, Df_ag):
    for ProvName in self.ProvLst:
      ThisProvCrop = self.ProvCropType(Df_ag, ProvName)
      for CropName in ThisProvCrop:
        #do a f test to validate  a linear model's fit
        # for this crop's data in 80 years

        #extract the 80-year historical data for ThisProvCrop 
        ThisCropDf = prov_ag[(prov_ag.GEO == ProvName) & 
                   (prov_ag.Type_of_crop == CropName)
                 & (prov_ag.Harvest_disposition == self.Harvest_disposition)
                ].dropna()
               
        # Extract dependent variables y and the independent variables X
        X = ThisCropDf.loc[:, ['TEMP', 'PRECIP']].values
        y = ThisCropDf.loc[:, ['VALUE']].values
        
        if (len(X) == len(y)) and (len(X) != 0):
        #fit a linear model with (X, y)
          X = sm.add_constant(X)
          model = sm.OLS(y, X).fit()
          
          #print(model.pvalues)
        
        #running a f-test for the validity of this model
          if (model.pvalues[0] < SIGNIFICANCE_LEVEL) and \
          (model.pvalues[1] < SIGNIFICANCE_LEVEL) and \
          (model.pvalues[2] < SIGNIFICANCE_LEVEL):
            f_test = 'Yes'
          else:
            f_test = 'No'

        #push the result of the f test onto self.record
        self.ProvRecord.append(ProvName)
        self.CropRecord.append(CropName)
        self.FTestRecord.append(f_test)

    #after the iteration, create the new dataframe
    LinearRegressionTest = {'Province_name': self.ProvRecord,
                'Crop_name': self.CropRecord,
                'Existence_of_linear_relation': 
                self.FTestRecord}

    self.result =  pd.DataFrame(LinearRegressionTest, columns = ['Province_name'
    , 'Crop_name', 'Existence_of_linear_relation'])

  def __print__(self):
    #display all the crops grown in each province and if
    #there is a linear relation between climate change and crop yield
    display(self.result)

  def __filter__(self):
    #display only the ones where a linear model applies
    self.filtered = self.result[self.result.Existence_of_linear_relation == 'Yes']
    display(self.filtered)

#calling the class and show the Summary
SummaryDf = LinearValidate()
SummaryDf.__print__()

#extract the pairs where a linear model can apply
# both temp and precip have .....
SummaryDf.__filter__()

#Test not included in submission. just to find the max and min values for
#setting the scale of y and x axises

max_precip = max((prov_ag["PRECIP"].dropna()).values)
max_temp = max((prov_ag["TEMP"].dropna()).values)
min_temp = min((prov_ag["TEMP"].dropna()).values)

#find a max yield of a specific crop

#find a max yield of every crop-type

#Step 2: Visualize the comparison between the 
#A: trend of temperature change OR,
#B: precipitation change and yield AND,
#C: change of a particular crop species in a Canadian province
# in the past 80 years

#The class is designed based on the following assumtions:
# a user is imagined to be provided the following entry boxes/drop-down list
# A: province
# B: a valid CropName 
# C: select either 'TEMP' or 'PRECIP'

#The class Graph displays the visuaization of the B and C's trend in the past 80
#years

class Graph:

  #set the inputs given by users as class variables, so that the province names
  #crop names etc can be used to create the plots
  def __init__(self, Prov, CropTp, TempORPrecip):
    self.Prov = Prov
    self.CropTp = CropTp
    self.TempORPrecip = TempORPrecip
    self.__setData__()
    self.__display__()
  
  # A. Extract all values which correspond to the province names, crop names, 
  # temperature values or precipitation values queries by users
  # B. set the historical values of crop yield as an array of dependent variables
  # and the temp/precip values as an array of dependent variables
  def __setData__(self):
    self.X = (prov_ag[(prov_ag.GEO == self.Prov) & 
                   (prov_ag.Type_of_crop == self.CropTp)
                 & (prov_ag.Harvest_disposition == 
                    'Average yield (kilograms per hectare)')
                ].dropna()["YEAR"]).values 
    self.production = (prov_ag[(prov_ag.GEO == self.Prov) & 
                   (prov_ag.Type_of_crop == self.CropTp)
                 & (prov_ag.Harvest_disposition == 
                    'Average yield (kilograms per hectare)')
                ].dropna()["VALUE"]).values
    if self.TempORPrecip == 'TEMP':
      self.key = 'TEMP'
    else:
      self.key = 'PRECIP'      
    self.independentVAR = (prov_ag[(prov_ag.GEO == self.Prov) & 
                   (prov_ag.Type_of_crop == self.CropTp)
                 & (prov_ag.Harvest_disposition == 
                    'Average yield (kilograms per hectare)')
                ].dropna()[self.key]).values

  #display the scatter plots and the linear regression lines
  # of dependent and independent variables 
  def __display__(self):
    
    ## find maximum and minimums for setting the scale of axis displayed
    self.max_temp =  max((prov_ag["TEMP"].dropna()).values)
    self.min_temp =  min((prov_ag["TEMP"].dropna()).values)
    self.max_precip =  max((prov_ag["PRECIP"].dropna()).values)
    self.max_yield = max((prov_ag[(prov_ag.Type_of_crop == self.CropTp) & 
                        (prov_ag.Harvest_disposition == 
                         'Average yield (kilograms per hectare)')]["VALUE"]
                .dropna()).values)
    
    # declare a subplot
    fig, ax1 = plt.subplots()
    
    #set the x-axis and left y-axis of the plot
    ax2 = ax1.twinx()
    ax1.plot(self.X, self.production, 'o', color = 'lightcoral', 
             label = 'Average Yield')   
    ax1.set_ylim(0,1000 + self.max_yield)    
    ax1.set_xlabel('Year')
    ax1.set_ylabel('kilograms per hectare')  

    #set the right y-axis of the plot
    if self.key == 'TEMP':
      ax2.plot(self.X, self.independentVAR, 'o', color = 'peachpuff', 
             label = 'Temperature')
      ax2.set_ylim(self.min_temp-2, self.max_temp+2)
      ax2.set_ylabel('Celsius')
    else:
      ax2.plot(self.X, self.independentVAR, 'o', color = 'lightblue', 
             label = 'Precipitation') 
      ax2.set_ylim(0, self.max_precip+2)     
      ax2.set_ylabel('mm') 

    # set and display a legend for the plot
    fig.legend(loc='upper left', bbox_to_anchor=(0.14, 0.87))

    # set and display the linear regression lines of the independent and 
    # dependent variables
    m, b = np.polyfit(self.X, self.production, 1)
    m1, b1 = np.polyfit(self.X, self.independentVAR, 1)

    ax1.plot(self.X, m*self.X+b, color='lightcoral')
    if self.key == "TEMP":
      ax2.plot(self.X, m1*self.X+b1, color='peachpuff')
    else:
      ax2.plot(self.X, m1*self.X+b1, color='lightblue')

    plt.show()



#Starting the assessment of linear relation 
#from sklearn.model_selection import train_test_split
#import numpy as np

#splitting data
#X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.5, random_state = 1)

#import LinearRegression module
#from sklearn.linear_model import LinearRegression
#create an LinearRegression object 
#LR = LinearRegression()
#training the liner regression model
#LR.fit(X_train, y_train)

#y_prediction = LR.predict(X_test)

#see the error between prediction value and actual values
#from sklearn.metrics import mean_squared_error
#score =  mean_squared_error(y_test, y_prediction)
#score

#splitting data for NS barley production per hectare
#X_train2, X_test2, y_train2, y_test2 = train_test_split(X2, y2, test_size = 0.5, random_state = 5)

#y_train2

#create an LinearRegression object 
#LR2 = LinearRegression()
#training the liner regression model
#LR2.fit(X_train2, y_train2)

#y_prediction2 = LR2.predict(X_test2)
#y_prediction2

#see the error between prediction value and actual values
##score2 =  mean_squared_error(y_test2, y_prediction2)
#score2

#visualize the very bad prediction for barley yield per hectare in NS:

#fig6, ax6 = plt.subplots(figsize=(7, 3.5))
#ax6.scatter(list(range(0, len(y_prediction2))) , y_prediction2, color = 'blue',alpha = 0.7)
#ax6.scatter(list(range(0, len(y_test2))), y_test2, color = 'red',alpha = 0.7)



